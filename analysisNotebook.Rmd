---
title: "Unbounded Implicit Learning - Analysis"
author: "Shanaa Modchalingam"
date: '2022-04-04'
output: 
  html_notebook:
    toc: true
    toc_float: true
    number_sections: true
    df_print: paged
    
---

```{r setup, include=FALSE, warning=FALSE}
rm(list = ls())      # clean environment

source("src/helper_funcs.R")
library(data.table)
library(tidyverse)
library(ggbeeswarm)
library(ez) #for ANOVAs
library(effectsize) # for eta-squared

```

# Some backround

A few studies show that implicit adaptation is 'rigid'. 
'Rigid' in this context means an upper boundary on adaptation.

These studies include (but are not limited to)

### Bond & Taylor (2015)
Here, people adapted to visuomotor rotations and provided aiming directions __prior__ to every reach. 
Implicit learning was measured by subtracting the aiming direction from the direction of movement.  

__Movement type:__ Balistic movements (<400 ms) and end-point feedback  
__Target parameters:__ 7 cm distance, radial target locations    
__Other:__ Participants were reminded "always moving directly to the target may not be effective" every 40 trials  

__Interesting tidbits:__ training to 1 target actually  resulted in higher implicit learning (30째!). 
2 and 4 targets resulted in 17 - 20째.  
Final implicit learning was ~10째 for 15, 30, 60 and 90째 rotations -- this did not differ between groups.


### Kim et al. (2019)
Here, people adapted to a constant visual error. That is, the error was present and consistent, regardless 

__Movement type:__ Clamped. Slicing movements (<300 ms)  
__Target parameters:__ 8 cm distance, radial target locations, 8 targets (in exp 1) or 4 targets (in exp 2)  
__Other:__ Patricipants were instructed to ignore the visual error.

__Interesting tidbits:__ 


### Modchalingam et al. (2019)

__Movement type:__ Non-balistic  
__Target parameters:__ 12 cm distance, located 45, 90, 135 degrees in polar coordinates  
__Other:__ 

__Interesting tidbits:__ 

# No-cursor analysis

First, we analyze the no-cursor data. Here-in lies our main question; do implicit aftereffects

## Load and summarize data

### Load the baseline corrected data

Load in the data frame, then separate for easier plotting

```{r, cols.print = 10, warning=FALSE}
# load in the large df
rot_all <- read_delim("data/bl_corrected/bl_corrected_data.csv", 
                               delim = ",", 
                               col_types = cols(.default = col_double(),
                                                targetangle_deg = col_factor(),
                                                strat_use = col_factor(),
                                                ppt = col_factor(),
                                                exp = col_factor(),
                                                block_num = col_factor(),
                                                reach_type = col_factor()))

# separate the nocursor and training data
rot_nocur <- rot_all %>%
  filter(reach_type == "nocursor")

rot_training <- rot_all %>%
  filter(reach_type == "reach")
```
```{r, cols.print = 10, warning=FALSE}
# palette
cbp1 <- c("#ff8000", "#e51636", "#0500a0")

```

The column of interest is "angular_dev". It contains, in degrees, the amount participants deviated from a straight-line reach towards the target.   


### Make a summary file with means for each participant

Each participant has 8 means: 2 for each block (one for each strategy use)
```{r}
nocur_summary <- rot_nocur %>%
  group_by(exp, ppt, block_num, strat_use) %>%
  summarise(mean_devs = mean(angular_dev), 
            sd = sd(angular_dev), 
            ci = vector_confint(angular_dev),
            n = n(), .groups = "drop")

head(nocur_summary)
```

## Statistics

### OMNIBUS ANOVA
We do a 3x4x2 mixed ANOVA (experiment x block x strategy use)
```{r, include=FALSE}
#performing a mixed effects model? (ezANOVA says it can't perform stuff on unbalanced data..)
temp_ANOVA <- nocur_summary %>%
  ezANOVA(wid = ppt,
        dv = mean_devs, 
        within = .(block_num, strat_use),
        between = exp,
        detailed = TRUE)
```
```{r}
#show and ANOVA + assumptions
print(temp_ANOVA$ANOVA)
```


### Implicit aftereffects
We will do 2 sets of analyses for all sets of data. First, we compare our measures in blocks where they first hit 60-degree rotations. Then, we compare block 4 in all groups (time = same).

*3x4 ANOVA (experiment x block)*
```{r, include=FALSE}
#performing a mixed effects model? (ezANOVA says it can't perform stuff on unbalanced data..)
temp_ANOVA <- nocur_summary %>% 
  filter(strat_use == '0') %>%
  ezANOVA(wid = ppt,
        dv = mean_devs, 
        within = .(block_num),
        between = exp,
        detailed = TRUE)
```
```{r}
#show and ANOVA + assumptions
print(temp_ANOVA$ANOVA)
```

To test whether the method of perturbation onset effected implicit learning, we compared the aftereffects of learning in No-Strategy trials.

*Early Implicit Aftereffects*
These are aftereffects measured during the blocks in which participants first encounter a 60-degree rotation.
```{r}
wo_strat_init_blocks <- nocur_summary %>% 
  filter(strat_use == '0') %>% #only the implicit aftereffects
  filter((exp == 'stepped' & block_num == '4') | #only the 5 blocks (1 and 4)
         (exp == 'abrupt' & block_num == '1') |
         (exp == 'ramped' & block_num == '1'))

```

Plot
```{r}
plot_desc_group_density(wo_strat_init_blocks, "exp", "mean_devs", title = "A. Initial Implicit Aftereffects")
```
Descriptive stats
```{r}
wo_strat_init_blocks %>% 
  group_by(exp) %>%
  summarise(mean = mean(mean_devs), 
            sd = sd(mean_devs), 
            ci = vector_confint(mean_devs),
            n = n())
```
ANOVA and post-hoc test
```{r}
temp_ANOVA <- aov(mean_devs ~ exp, data = wo_strat_init_blocks)

#show ANOVA + assumptions
print(summary(temp_ANOVA), digits = 6)
eta_squared(temp_ANOVA)
TukeyHSD(temp_ANOVA)
```
Bayes Factors
```{r, include=FALSE}
anovaBF(mean_devs ~ exp, data = wo_strat_init_blocks, progress=FALSE)

tmp_bf_abr_ramp <- bayes_t_test(wo_strat_init_blocks, "exp", "abrupt", "ramped", "mean_devs")
tmp_bf_stp_ramp <- bayes_t_test(wo_strat_init_blocks, "exp", "stepped", "ramped", "mean_devs")
tmp_bf_stp_abr <- bayes_t_test(wo_strat_init_blocks, "exp", "stepped", "abrupt", "mean_devs")
```
```{r}
print(tmp_bf_abr_ramp)
print(tmp_bf_stp_ramp)
print(tmp_bf_stp_abr)
```



2. Time-constant measures

```{r}
wo_strat_final_blocks <- nocur_summary %>% 
  filter(strat_use == '0') %>% #only the implicit aftereffects
  filter(block_num == '4') # only comparing block 4 data
```
```{r}
#plot
plot_desc_group_density(wo_strat_final_blocks, "exp", "mean_devs", title = "B. Block 4 Implicit Aftereffects")
```
```{r}
# descriptives
wo_strat_final_blocks %>% 
  group_by(exp) %>%
  summarise(mean = mean(mean_devs), 
            sd = sd(mean_devs), 
            ci = vector_confint(mean_devs),
            n = n())
```
```{r}
no_cur_ANOVA <- aov(mean_devs ~ exp, data = wo_strat_final_blocks)

#show ANOVA + assumptions
print(summary(no_cur_ANOVA), digits = 6)
eta_squared(no_cur_ANOVA)
TukeyHSD(no_cur_ANOVA)
```
Bayes Factors
```{r, include=FALSE}
anovaBF(mean_devs ~ exp, data = wo_strat_final_blocks, progress=FALSE)

tmp_bf_abr_ramp <- bayes_t_test(wo_strat_final_blocks, "exp", "abrupt", "ramped", "mean_devs")
tmp_bf_stp_ramp <- bayes_t_test(wo_strat_final_blocks, "exp", "stepped", "ramped", "mean_devs")
tmp_bf_stp_abr <- bayes_t_test(wo_strat_final_blocks, "exp", "stepped", "abrupt", "mean_devs")
```
```{r}
print(tmp_bf_abr_ramp)
print(tmp_bf_stp_ramp)
print(tmp_bf_stp_abr)
```


### Explicit strategy
Same analysis pipeline as for the implicit measures

First, we need to actually calculate strategy
```{r}
#first get explicit strat for each ppt

nocur_summary_wide <- nocur_summary %>%
  select(-sd, -ci) %>%
  pivot_wider(names_from = "strat_use", 
              values_from = mean_devs, 
              names_prefix = "strat_") %>%
  mutate(strategy = strat_1 - strat_0)
```

1. Initial measures
```{r}
strat_initial_blocks <- nocur_summary_wide %>% 
  filter((exp == 'stepped' & block_num == '4') | #only the 5 blocks (1 and 4)
         (exp == 'abrupt' & block_num == '1') |
         (exp == 'ramped' & block_num == '1'))
```
```{r}
#plot
plot_desc_group_density(strat_initial_blocks, "exp", "strategy", title = "A. Initial Strategy")
```
```{r}
# descriptives
strat_initial_blocks %>% 
  group_by(exp) %>%
  summarise(mean = mean(strategy), 
            sd = sd(strategy), 
            ci = vector_confint(strategy),
            n = n())
```
```{r}

no_cur_ANOVA <- aov(strategy ~ exp, data = strat_initial_blocks)

#show ANOVA + assumptions
print(summary(no_cur_ANOVA), digits = 6)
eta_squared(no_cur_ANOVA)
TukeyHSD(no_cur_ANOVA)
```

Bayes Factors
```{r, include=FALSE}
anovaBF(strategy ~ exp, data = strat_initial_blocks, progress=FALSE)

tmp_bf_abr_ramp <- bayes_t_test(strat_initial_blocks, "exp", "abrupt", "ramped", "strategy")
tmp_bf_stp_ramp <- bayes_t_test(strat_initial_blocks, "exp", "stepped", "ramped", "strategy")
tmp_bf_stp_abr <- bayes_t_test(strat_initial_blocks, "exp", "stepped", "abrupt", "strategy")
```
```{r}
print(tmp_bf_abr_ramp)
print(tmp_bf_stp_ramp)
print(tmp_bf_stp_abr)
```


2. Same but for the final block
```{r}
strat_final_blocks <- nocur_summary_wide %>% 
  filter(block_num == '4')
```
```{r}
#plot
plot_desc_group_density(strat_final_blocks, "exp", "strategy", title = "B. BLock 4 Strategy")
```

```{r}
# descriptives
strat_final_blocks %>% 
  group_by(exp) %>%
  summarise(mean = mean(strategy), 
            sd = sd(strategy), 
            ci = vector_confint(strategy),
            n = n())
```

```{r}

no_cur_ANOVA <- aov(strategy ~ exp, data = strat_final_blocks)

#show ANOVA + assumptions
print(summary(no_cur_ANOVA), digits = 6)
eta_squared(no_cur_ANOVA)
TukeyHSD(no_cur_ANOVA)
```
Bayes Factors
```{r, include=FALSE}
anovaBF(strategy ~ exp, data = strat_final_blocks, progress=FALSE)

tmp_bf_abr_ramp <- bayes_t_test(strat_final_blocks, "exp", "abrupt", "ramped", "strategy")
tmp_bf_stp_ramp <- bayes_t_test(strat_final_blocks, "exp", "stepped", "ramped", "strategy")
tmp_bf_stp_abr <- bayes_t_test(strat_final_blocks, "exp", "stepped", "abrupt", "strategy")
```
```{r}
print(tmp_bf_abr_ramp)
print(tmp_bf_stp_ramp)
print(tmp_bf_stp_abr)
```

3. Compare blocks 1 and 4 for abrupt and gradual data


```{r}
strat_betwn_block <- nocur_summary_wide %>% 
  filter(block_num == '4' | block_num =='1', exp == 'abrupt' | exp == 'ramped')

plot_desc_group_density(strat_betwn_block, "block_num", "strategy", subgroup = "exp", title = "C. Strategy Use blocks 1 v 4")
```

```{r}
anovaBF(strategy ~ exp * block_num, data = strat_betwn_block, progress=FALSE)
```
```{r}
btwn_block_strat_ANOVA <- aov(strategy ~ exp * block_num, data = strat_betwn_block)
print(summary(btwn_block_strat_ANOVA), digits = 6)
eta_squared(btwn_block_strat_ANOVA)
TukeyHSD(btwn_block_strat_ANOVA)
```



# Reach training analysis

Use bl_corrected data

```{r}

training_summary_per_trial <- rot_training %>%
  group_by(exp, trial_num_cont) %>%
  summarise(mean_devs = mean(angular_dev), sd = sd(angular_dev), 
            ci = vector_confint(angular_dev), .groups = "drop")

#training_summary$rotation_angle <- factor(training_summary$rotation_angle, levels=c("-15", "-30", "-45", "-60"))
training_summary_per_trial$trial_num_cont <- training_summary_per_trial$trial_num_cont - 66
```


## Statistics

Plot of relevant groups

```{r}
rot_training_trial_sets <- rot_training %>%
  filter(trial_set != 10 & trial_set != 20) %>%
  group_by(exp, ppt, trial_set) %>%
  summarise(angular_dev_mean = mean(angular_dev), 
            sd = sd(angular_dev), 
            ci = vector_confint(angular_dev),
            n = n(), .groups = "drop")
  # group_by(exp, trial_set) %>%
  # summarise(trial_set_mean = mean(angular_dev_mean), 
  #           sd = sd(angular_dev_mean), 
  #           ci = vector_confint(angular_dev_mean),
  #           n = n(), .groups = "drop")

head(rot_training_trial_sets)
```

```{r}
plot_desc_group_density(rot_training_trial_sets, "trial_set", "angular_dev_mean", subgroup = "exp", title = "Training trial sets")
```

We confirm that all groups learn

```{r}
training_final_trial_set <- rot_training_trial_sets %>% 
  filter(trial_set == '3')
```

```{r}
#plot
plot_desc_group_density(training_final_trial_set, "exp", "angular_dev_mean", title = "Block 4 Adaptation")
```

```{r}
# descriptives
training_final_trial_set %>% 
  group_by(exp) %>%
  summarise(mean = mean(angular_dev_mean), 
            norm_mean = mean(angular_dev_mean)/60,
            sd = sd(angular_dev_mean), 
            ci = vector_confint(angular_dev_mean),
            n = n())
```

```{r}

training_ANOVA <- aov(angular_dev_mean ~ exp, data = training_final_trial_set)

#show ANOVA + assumptions
print(summary(training_ANOVA), digits = 6)
eta_squared(training_ANOVA)
TukeyHSD(training_ANOVA)
```

Bayes Factors
```{r, include=FALSE}
anovaBF(angular_dev_mean ~ exp, data = training_final_trial_set, progress=FALSE)

tmp_bf_abr_ramp <- bayes_t_test(training_final_trial_set, "exp", "abrupt", "ramped", "angular_dev_mean")
tmp_bf_stp_ramp <- bayes_t_test(training_final_trial_set, "exp", "stepped", "ramped", "angular_dev_mean")
tmp_bf_stp_abr <- bayes_t_test(training_final_trial_set, "exp", "stepped", "abrupt", "angular_dev_mean")
```
```{r}
print(tmp_bf_abr_ramp)
print(tmp_bf_stp_ramp)
print(tmp_bf_stp_abr)
```

# Combining all data

Plotting all data
```{r}
# make a summary df
rot_all_summary <- rot_all %>%
  group_by(exp, trial_num_cont, strat_use) %>%
  summarise(mean = mean(angular_dev),
            sd = sd(angular_dev), 
            ci = vector_confint(angular_dev),
            n = n(), .groups = "drop")
```

plot
```{r}
p <- rot_all %>% 
  ggplot(aes(trial_num_cont, angular_dev, colour = exp, shape = strat_use)) +
  geom_point(alpha = 0.04)+
  geom_point(data = rot_all_summary, aes(y = mean)) +
  scale_shape_manual(values=c(20, 2))+
  # stat_summary(fun=mean, geom="point", size=3, color="red") +
  theme_minimal() +
  theme(panel.grid.major.y = element_line(colour = "#CCCCCC")) +
  scale_y_continuous(limits = c(-20, 90)) +
  ggtitle("All data")

p

# ggsave(p, height = 9, width = 16, device = "svg", filename = "data/paper_figs/all_reaches.svg")
```

Repeat for normalized angular deviations
```{r}
rot_norm_summary <- rot_all %>%
  group_by(exp, trial_num_cont, strat_use) %>%
  summarise(mean = mean(norm_angular_dev),
            sd = sd(norm_angular_dev), 
            ci = vector_confint(norm_angular_dev),
            n = n(), .groups = "drop")
```
plot
```{r}
p <- rot_all %>% 
  ggplot(aes(trial_num_cont, norm_angular_dev, colour = exp, shape = strat_use)) +
  geom_point(alpha = 0.04) +
  geom_point(data = rot_norm_summary, aes(y = mean)) +
  scale_shape_manual(values=c(20, 2))+
  # stat_summary(fun=mean, geom="point", size=3, color="red") +
  theme_minimal() +
  theme(panel.grid.major.y = element_line(colour = "#CCCCCC")) +
  scale_y_continuous(limits = c(-0.5, 1.5)) +
  ggtitle("All data")

p

# ggsave(p, height = 9, width = 16, device = "svg", filename = "data/paper_figs/all_reaches_norm.svg")
```


# Slopes of no-cusor reaches over time
Make some summary data sets
```{r, warning=FALSE}
#start with the no cursor data
# rot_nocur <- rot_all %>%
#   filter(reach_type == "nocursor")

# use block trial nums
# block_trials <- list()
# i <- 1
# for(ppt_i in unique(rot_nocur$ppt)){
#   for (strat_use_i in unique(rot_nocur$strat_use)){
#     for (block_num_i in unique(rot_nocur$block_num_detailed)){
#       for (exp_i in unique(rot_nocur$exp)){
#     
#         temp <- rot_nocur %>%
#           filter(strat_use == strat_use_i, block_num_detailed == block_num_i, 
#                  exp == exp_i, ppt == ppt_i)
#         # print(c(strat_use_i, block_num_i, exp_i))
#         temp = mutate(temp, trial = trial_num_cont - min(trial_num_cont) + 1)
#         
#         #NOTE LARGE TIME CONSUMING WARNING MESSAGE HERE!
#         # save this one df to datalist
#         block_trials[[i]] <- temp
#           
#         i <- i+1
#       }
#     }
#   }
# }
# test <- do.call(rbind, block_trials)
# 
# 
# rot_nocur <- test
  

rot_nocur_trial_summary <- rot_nocur %>%
  group_by(exp, block_num, trial_num_cont, strat_use) %>%
  summarise(mean = mean(angular_dev),
            sd = sd(angular_dev), 
            ci = vector_confint(angular_dev),
            n = n(), .groups = "drop")

rot_nocur_block_summary_ppt <-  rot_nocur %>%
  group_by(exp, ppt, block_num, strat_use) %>%
  summarise(angular_dev_temp = mean(angular_dev),
            sd = sd(angular_dev), 
            ci = vector_confint(angular_dev),
            n = n(), .groups = "drop") 

# add slopes to the above summary table

beta_list <- list()
intercept_list <- list()
i <- 1


for (strat_use_i in unique(rot_nocur_block_summary_ppt$strat_use)){
  for (block_num_i in unique(rot_nocur_block_summary_ppt$block_num)){
    for (ppt_i in unique(rot_nocur_block_summary_ppt$ppt)){
      # if (exp_i == "ramped" & block_num_i == "1.1"){
      #   next
      # }
      temp <- rot_nocur %>%
          filter(strat_use == strat_use_i, block_num == block_num_i,
                 ppt == ppt_i)
      
      lm_fit <- lm(temp$angular_dev ~ temp$trial)
      
      beta_list[[i]] <- lm_fit$coefficients[2]
      intercept_list[[i]] <- lm_fit$coefficients[1]
      i <- i+1 
    }
  }
}

temp <- do.call(rbind, beta_list)[,]
rot_nocur_block_summary_ppt$beta <- temp

temp <- do.call(rbind, intercept_list)[,]
rot_nocur_block_summary_ppt$intercept <- temp

rot_nocur_detailed_block_summary_ppt <- rot_nocur_block_summary_ppt %>%
  group_by(exp, block_num, strat_use) %>%
  summarise(mean_angular_dev = mean(angular_dev_temp),
            sd = sd(angular_dev_temp), 
            ci = vector_confint(angular_dev_temp),
            n = n(), .groups = "drop")


```
Isolate without strategy reaches
```{r}
# test <- rot_nocur_trial_summary %>%
#   filter(strat_use == 0, block_num_detailed == 1.1, exp == "stepped")
# test = mutate(test, trial = trial_num_cont - min(trial_num_cont) + 1)
# lm.stepped_1.1 <- lm(test$mean ~ test$trial)

# add intercept, slope, fitted values, and r^2 to detailed block summary
rot_nocur_detailed_block_summary$intercept <- NA
rot_nocur_detailed_block_summary$slope <- NA
#rot_nocur_detailed_block_summary$fitted_values <- list(as.numeric(c(1,2,3,4)))
#rot_nocur_detailed_block_summary$trial_list <- list(as.numeric(c(1,2,3,4)))
rot_nocur_detailed_block_summary$r_2 <- NA
rot_nocur_trial_summary$fitted_values <- NA
# rot_nocur_trial_summary$short_trials <- NA


for (strat_use_i in unique(rot_nocur_trial_summary$strat_use)){
  for (block_num_i in unique(rot_nocur_trial_summary$block_num)){
    for (exp_i in unique(rot_nocur_trial_summary$exp)){
      if (exp_i == "ramped" & block_num_i == "1.1"){
        next
      }
      #isolate df
      temp <- rot_nocur_trial_summary %>%
        filter(strat_use == strat_use_i, block_num == block_num_i, exp == exp_i)
      # print(c(strat_use_i, block_num_i, exp_i))
      # temp = mutate(temp, trial = trial_num_cont - min(trial_num_cont) + 1)
      
      lm_fit <- lm(temp$mean ~ temp$trial)
      
      bool_arr <- rot_nocur_detailed_block_summary$strat_use == strat_use_i & 
                                         rot_nocur_detailed_block_summary$block_num == block_num_i &
                                          rot_nocur_detailed_block_summary$exp == exp_i
      
      rot_nocur_detailed_block_summary[ bool_arr, ]$intercept <- paste("intercept: ", round(lm_fit$coefficients[1], 2))
      rot_nocur_detailed_block_summary[ bool_arr, ]$slope <- paste("slope: ", round(lm_fit$coefficients[2], 2))
      #rot_nocur_detailed_block_summary[ bool_arr, ]$fitted_values <- list(array(lm_fit$fitted.values))
      #rot_nocur_detailed_block_summary[ bool_arr, ]$trial_list <- list(array(temp$trial_num_cont))
      rot_nocur_detailed_block_summary[ bool_arr, ]$r_2 <- paste("r_2: ", round(summary(lm_fit)$r.squared, 2))
      
      bool_arr <- rot_nocur_trial_summary$strat_use == strat_use_i & 
                                         rot_nocur_trial_summary$block_num == block_num_i &
                                          rot_nocur_trial_summary$exp == exp_i
      rot_nocur_trial_summary[bool_arr, ]$fitted_values <- array(lm_fit$fitted.values)
      # [bool_arr, ]$short_trials <- temp$trial
    }
  }
}
```

```{r}
p <- rot_nocur_trial_summary %>% 
  ggplot(aes(trial_num_cont, mean, colour = exp, shape = strat_use)) +
  scale_shape_manual(values=c(20, 2))+
  # stat_summary(fun=mean, geom="point", size=3, color="red") +
  theme_minimal() +
  theme(panel.grid.major.y = element_line(colour = "#CCCCCC"),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) +
  ggtitle("Decay during no-cursor reaches") +
  scale_y_continuous(limits = c(-0.5, 35)) +
  scale_x_continuous(limits = c(0, 10), breaks = c(0,5, 10), 
                     labels = c(0, 5, 10))



p <- p +
  geom_line(aes(y = fitted_values)) +
  geom_point(aes( x = trial_num_cont, y = mean), alpha = 0.5) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "stepped"), 
#             aes(x = 9, y = 40, label = intercept),
#             nudge_y = 0, size = 3, hjust = 0) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "ramped"), 
#             aes(x = 9, y = 40, label = intercept),
#             nudge_y = 10, size = 3, hjust = 0) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "abrupt"), 
#             aes(x = 9, y = 40, label = intercept),
#             nudge_y = 20, size = 3, hjust = 0) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "stepped"), 
#             aes(x = 9, y = 43, label = slope),
#             nudge_y = 0, size = 3, hjust = 0) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "ramped"), 
#             aes(x = 9, y = 43, label = slope),
#             nudge_y = 10, size = 3, hjust = 0) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "abrupt"), 
#             aes(x = 9, y = 43, label = slope),
#             nudge_y = 20, size = 3, hjust = 0) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "stepped"), 
#             aes(x = 9, y = 46, label = r_2),
#             nudge_y = 0, size = 3, hjust = 0) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "ramped"), 
#             aes(x = 9, y = 46, label = r_2),
#             nudge_y = 10, size = 3, hjust = 0) +
#   geom_text(data = filter(rot_nocur_detailed_block_summary, exp == "abrupt"), 
#             aes(x = 9, y = 46, label = r_2),
#            nudge_y = 20, size = 3, hjust = 0) +
    NULL

p <- p +
  facet_grid(rows = vars(strat_use), cols = vars(block_num))

p

ggsave(p, height = 5, width = 9, device = "png", filename = "data/paper_figs/no_cur_regressions.png")
```
ANOVA on slopes
```{r}
rot_nocur_block_summary_ppt_nostrat <- rot_nocur_block_summary_ppt %>%
  filter(strat_use == 0)
slope_aov <- ezANOVA( data = rot_nocur_block_summary_ppt_nostrat,
                           wid = ppt,
                           dv = beta, 
                           within = block_num,
                           between = exp,
                           detailed = FALSE,
                           return_aov = TRUE)
print(slope_aov)
```
ANOVA on intercepts
```{r}
rot_nocur_block_summary_ppt_nostrat <- rot_nocur_block_summary_ppt %>%
  filter(strat_use == 0)
intercept_aov <- ezANOVA( data = rot_nocur_block_summary_ppt_nostrat,
                           wid = ppt,
                           dv = intercept, 
                           within = block_num,
                           between = exp,
                           detailed = FALSE,
                           return_aov = TRUE)
print(intercept_aov)
```

# Paper Figures

### Implicit aftereffects
```{r}
wo_strat_blocks <- nocur_summary %>% 
  filter(strat_use == '0') %>% #only the implicit aftereffects
  filter((exp == 'stepped' & block_num == '4') | 
           (exp == 'abrupt' & block_num == '1') |
           (exp == 'ramped' & block_num == '1') | 
           (exp == 'abrupt' & block_num == '4') |
           (exp == 'ramped' & block_num == '4')) %>%
  unite(exp_block, exp, block_num)

# make descriptive df
desc_df <- wo_strat_blocks %>%
  group_by(exp_block) %>%
  summarise(means = mean(mean_devs), 
            sd = sd(mean_devs), 
            ci = vector_confint(mean_devs),
            n = n(), .groups = "drop")

# plot
p <- plot_nice_group_density(wo_strat_blocks,
                        desc_df,
                        group = "exp_block", 
                        y = "mean_devs", 
                        title = "Implicit Aftereffects")

# set colour
p <- p + scale_color_manual(values = c(cbp1[3],
                                  cbp1[3],
                                  cbp1[1],
                                  cbp1[1],
                                  cbp1[2]), labels = c("Abrupt Block 1", 
                                                       "Abrupt Block 4",
                                                       "Ramped Block 1",
                                                       "Ramped Block 4",
                                                       "Stepped Block 4"))
p <- p + theme(panel.grid.major.y = element_line(colour = "#CCCCCC"),
               panel.grid.major.x = element_blank(),
               axis.text.x=element_blank()) + 
  xlab(NULL) + ylab("reach aftereffects without strategy (째)")
p

ggsave(p, height = 5, width = 4, device = "png", filename = "data/paper_figs/implicit_aes.png")
```

### Explicit Strategies
```{r}
strat_blocks <- nocur_summary_wide %>% 
  filter((exp == 'stepped' & block_num == '4') | 
           (exp == 'abrupt' & block_num == '1') |
           (exp == 'ramped' & block_num == '1') | 
           (exp == 'abrupt' & block_num == '4') |
           (exp == 'ramped' & block_num == '4')) %>%
  unite(exp_block, exp, block_num)

# make descriptive df
desc_df <- strat_blocks %>%
  group_by(exp_block) %>%
  summarise(means = mean(strategy), 
            sd = sd(strategy), 
            ci = vector_confint(strategy),
            n = n(), .groups = "drop")

# plot
p <- plot_nice_group_density(strat_blocks,
                        desc_df,
                        group = "exp_block", 
                        y = "strategy", 
                        title = "Explicit Strategies")

# set colour
p <- p + scale_color_manual(values = c(cbp1[3],
                                  cbp1[3],
                                  cbp1[1],
                                  cbp1[1],
                                  cbp1[2]), labels = c("Abrupt Block 1", 
                                                       "Abrupt Block 4",
                                                       "Ramped Block 1",
                                                       "Ramped Block 4",
                                                       "Stepped Block 4"))
p <- p + theme(panel.grid.major.y = element_line(colour = "#CCCCCC"),
               panel.grid.major.x = element_blank(),
               axis.text.x=element_blank()) + 
  xlab(NULL) + ylab("reach aftereffects without strategy (째)")
p

ggsave(p, height = 5, width = 4, device = "png", filename = "data/paper_figs/explicit_aes.png")
```







# Older reach training analysis
We use the blocks of interest
```{r}
rot_training_ana_blocks <- rot_training %>%
  filter(block_num != 10) %>%
  group_by(exp, ppt, block_num) %>%
  summarise(angular_dev_mean = mean(angular_dev), 
            sd = sd(angular_dev), 
            ci = vector_confint(angular_dev),
            n = n(), .groups = "drop")
```

### Training ANOVA
This one will need to be a 3xN ANOVA (exp x blocks), where N is the number of blocks being used.
```{r}
training_anova <- ezANOVA( data = rot_training_ana_blocks,
                           wid = ppt,
                           dv = angular_dev_mean, 
                           within = block_num,
                           between = exp,
                           detailed = FALSE,
                           return_aov = TRUE)
print(training_anova)
```
### Post hoc test: 
Note the Tukey's HSD is for INDEPENDENT tests. Doesn't work for repeated measures like we have here (blocks)
For the old paper, we just report ANOVA results, no post hocs for these.

```{r}
#descriptives
desc_temp <- rot_training_ana_blocks %>%
  group_by(exp, block_num) %>%
  summarise(mean_dev = mean(angular_dev_mean), 
            sd = sd(angular_dev_mean), 
            ci = vector_confint(angular_dev_mean),
            n = n(), .groups = "drop")

desc_temp
```
### Plot
```{r}
p <- rot_training_ana_blocks %>%
  ggplot(aes(block_num, angular_dev_mean, colour = exp)) +
  ggtitle("Training over blocks and experiments") +
  geom_beeswarm(dodge.width = 0.6, alpha = 0.2) +
  geom_point(data = desc_temp,
             aes(block_num, mean_dev, colour = exp),
             size = 5, alpha = 0.6, 
             position = position_dodge(width = .6)) + 
  geom_linerange(data = desc_temp,
                 aes(block_num, mean_dev, colour = exp, 
                     ymin = mean_dev - ci, ymax = mean_dev + ci), 
                 lwd = 5, alpha = 0.4, 
                 position = position_dodge(width = .6)) +
  scale_y_continuous(limits = c(-10, 75), 
                     breaks = c(0, 15, 30, 45, 60), 
                     name = "hand deviation (째)") +
  scale_x_discrete(name = "block", 
                   labels = c("Initial", '1', '2', '3', '4')) +
  theme_minimal() +
  theme(panel.grid.major.y = element_line(colour = "#CCCCCC")) +
  scale_colour_manual(values=c( "#d40000", "#084594", "#8365b5"), 
                       breaks=c("stepped", "abrupt", "ramped"),
                       labels=c( "stepwise", "abrupt", "gradual")) +
  NULL
p

p <- p +
    theme(text = element_text(size=20), 
        axis.text = element_text(size=20), 
        legend.text = element_text(size=24))

# ggsave(p, height = 7, width = 10, device = "svg", filename = "data/paper_figs/training_plot_blocks.svg")
```
# Additional Analyses
## Rebounds

We start with the baseline-corrected reach data (rot_training).
```{r}
# make a list of rebound trials
rebound_trials <- c(46, 67, 112, 133, 178, 199, 244) #block 4 only has 1 rebound trial
pre_reb_trials <- rebound_trials - 1

rot_rebounds <- rot_training %>%
  filter(trial_num_cont %in% rebound_trials) %>%
  select(-block_num)

rot_rebounds$pre_reb_dev <- rot_training %>%
  filter(trial_num_cont %in% pre_reb_trials) %>%
  select(angular_dev) %>% as_vector()

rot_rebounds$decay <- rot_rebounds$pre_reb_dev - rot_rebounds$angular_dev

rot_rebounds$trial_num_cont <- as.factor(rot_rebounds$trial_num_cont)

```



```{r}

#descriptives
desc_temp <- rot_rebounds %>%
  group_by(exp, trial_num_cont, NULL) %>%
  summarise(mean_dev = mean(angular_dev), 
            sd = sd(angular_dev), 
            ci = vector_confint(angular_dev),
            n = n(), .groups = "drop")
desc_temp$trial_num_cont <- as.factor(desc_temp$trial_num_cont)
rot_rebounds$trial_num_cont <- as.factor(rot_rebounds$trial_num_cont)

p <- desc_temp %>%
  ggplot(aes(trial_num_cont, mean_dev, colour = exp)) +
  ggtitle("Rebounds during training") +
  geom_beeswarm(data = rot_rebounds,
                aes(y = angular_dev),
                dodge.width = 0.6, alpha = 0.2) +
  geom_point(size = 5, alpha = 0.6, 
             position = position_dodge(width = .6)) + 
  geom_linerange(aes(ymin = mean_dev - ci, ymax = mean_dev + ci), 
                 lwd = 5, alpha = 0.4, 
                 position = position_dodge(width = .6))

p

```


```{r}
#descriptives
desc_temp <- rot_rebounds %>%
  group_by(exp, trial_num_cont) %>%
  summarise(mean_decay = mean(decay), 
            sd = sd(decay), 
            ci = vector_confint(decay),
            n = n(), .groups = "drop")

p <- desc_temp %>%
  ggplot(aes(trial_num_cont, mean_decay, colour = exp)) +
  ggtitle("Decay during no-cursor trials training") +
  geom_beeswarm(data = rot_rebounds,
                aes(y = decay),
                dodge.width = 0.6, alpha = 0.2) +
  geom_point(size = 5, alpha = 0.6, 
             position = position_dodge(width = .6)) + 
  geom_linerange(aes(ymin = mean_decay - ci, ymax = mean_decay + ci), 
                 lwd = 5, alpha = 0.4, 
                 position = position_dodge(width = .6)) +
  scale_y_continuous(limits = c(-30, 75), 
                     breaks = c(0, 15, 30, 45, 60), 
                     name = "decay over no-cursor trials (째)")

p

```


## Measures of explicit learning

We measure explicit adaptation, but it is sometimes taken as the difference between performance in training trials and implicit probes.
Note: It may be that contextual cues like the cursor being present matters (e.g. in contextual inference models)

Let's compare the 2:
per ppt, we need.. implicit learning per block (from nucursor data), training performance per block (from the previous section)

```{r}
# we can start with the implicit data. Formatted so that each participant has some values for each block
pre_reb_devs <- rot_rebounds %>% 
  filter(trial_num_cont %in% c(46, 112, 178, 244)) %>%
  select(ppt, pre_reb_dev) 

pre_reb_devs <- pre_reb_devs %>% 
  bind_cols(block_num = as.factor(rep(1:4, nrow(pre_reb_devs)/4)))
  
per_ppt_format <- nocur_summary %>%
  select(-sd, -ci, -n) %>% #getting rid of sanity check variables
  spread(strat_use, mean_devs) %>%
  rename(without_strat_dev = '0'  , with_strat_dev = '1')

combined_data <- left_join(per_ppt_format, pre_reb_devs, by = c("ppt", "block_num")) %>%
  mutate(measured_exp = with_strat_dev - without_strat_dev, inferred_exp = pre_reb_dev - without_strat_dev)


head(combined_data)
```

Plot the different explicit measures

```{r}
#descriptives
desc_temp <- combined_data %>%
  group_by(exp, block_num) %>%
  summarise(measured_exp_mean = mean(measured_exp), 
            measured_exp_sd = sd(measured_exp), 
            measured_exp_ci = vector_confint(measured_exp),
            inferred_exp_mean = mean(inferred_exp), 
            inferred_exp_sd = sd(inferred_exp), 
            inferred_exp_ci = vector_confint(inferred_exp),
            n = n(), .groups = "drop")
head(desc_temp)
```

```{r}
p <- desc_temp %>%
  ggplot(aes(block_num, measured_exp_mean, colour = exp)) +
  ggtitle("Measured vs inferred explicit (circles = measured)") +
  geom_point(size = 5, alpha = 0.6, 
             position = position_dodge(width = .6)) + 
  geom_linerange(aes(ymin = measured_exp_mean - measured_exp_ci, ymax = measured_exp_mean + measured_exp_ci), 
                 lwd = 5, alpha = 0.4, 
                 position = position_dodge(width = .6)) +
  geom_point(aes(y = inferred_exp_mean),
             size = 5, alpha = 0.6, shape = 18,
             position = position_dodge(width = .6)) + 
  geom_linerange(aes(ymin = inferred_exp_mean - inferred_exp_ci, ymax = inferred_exp_mean + inferred_exp_ci), 
                 lwd = 5, alpha = 0.4, 
                 position = position_dodge(width = .6)) + 
  scale_y_continuous(name = "explicit learning (째)") +
  scale_x_discrete(name = "block")
  
p
```
Measured explicit learning = markedly lower

# Plots for print
```{r}
plot_nice_group_density(training_final_trial_set, exp, angular_dev_mean, title = "Block 4 Adaptation")
```

```{r}
#test
mutate(rot_nocur, distance = sqrt(mousex_px^2 + mousey_px^2)) -> test
```

